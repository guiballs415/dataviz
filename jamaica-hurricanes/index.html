<!doctype html>
<html lang="en">

	<head>
	    <meta charset="utf-8">
		<title>Hurricanes Beryl and Melissa in Jamaica</title>

		<script src="data/cyclones-beryl.js"></script>
		<script src="data/cyclones-melissa.js"></script>

		<script>
			var map_spec = {

				center: { lat: 17.8, lng: -77.5 },
				zoom: 7,

				bounds: {
					southwest: { lat: 16.5, lng: -80.0 }, 
					northeast: { lat: 18.5, lng: -75.0 }
				},

				hurricanes: new Array(),
			};

			var hurricane_spec = {

				path: {
					width: 4,
				},

				style: {
					strokeOpacity: 0,
					clickable: false,
				},

				opacity: {
					wind_34: 0.25,
					wind_50: 0.55,
					wind_64: 0.60,
					wind_max: 0.60,
				},
				num_wind_buckets: 4,

				z_index: 2,

				mph_per_knot: 1.15078,

				// Chaikin's corner cutting iterations
				// https://www.cs.unc.edu/~dm/UNC/COMP258/LECTURES/Chaikins-Algorithm.pdf
				loop_refinement_steps: 6,

				wind_tunnel_step: 3, // hours
			};

			var time_spec = {

				animation: {

					speed: 6.3, // hours of cyclone per seconds of animation
					frame_rate: 25 / 1000, // fps - frames per millisecond

					timer: null,
					t0: null,
					h0: 0,
					dh: 0,
				},

				months: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
				weekdays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
			};

			var beryl_spec = {

				name: "Beryl",
				data: cyclones_beryl,
				timeseries: null,

				// Darkest 4 colors from 6-color blue palette at https://spectrum.googleplex.com/#/sequential
				color: {
					path: "#2e7ebc",
					wind_34: "#a6cde4",
					wind_50: "#63a8d3",
					wind_64: "#2e7ebc",
					wind_max: "#084594",
				},

				z_index: null,

				// Graphical elements
				path: null,
				center: null,
				polygons: {
					wind_area: [ null, null, null, null ],
					wind_tunnel: [ null, null, null, null ],
				},

				animation: {
					start: 100, // hours from first time point
					end: 144, // hours from first time point - if null then last time point
				},
				wind_tunnel: {
					start: 20, // hours from first time point
					end: 180, // hours from first time point - if null then last time point
				},

				weekday_offset: {
					day: "Jun 28",
					weekday: "Fri",
				},
			};

			var melissa_spec = {

				name: "Melissa",
				data: cyclones_melissa,
				timeseries: null,

				// Darkest 4 colors from 6-color purple palette at https://spectrum.googleplex.com/#/sequential
				color: {
					path: "#8a52a5",
					wind_34: "#a5c1dc",
					wind_50: "#8c8dc2",
					wind_64: "#8a52a5",
					wind_max: "#6e016b",
				},

				z_index: null,

				// Graphical elements
				path: null,
				center: null,
				polygons: {
					wind_area: [ null, null, null, null ],
					wind_tunnel: [ null, null, null, null ],
				},

				animation: {
					start: 114, // hours from first time point
					end: 228, // hours from first time point - if null then last time point
				},
				wind_tunnel: {
					start: 40, // hours from first time point
					end: 275, // hours from first time point - if null then last time point
				},

				weekday_offset: {
					day: "Oct 20",
					weekday: "Mon",
				},
			};

			function get_nhc_time_cyclones(google_time_cyclones) {

				var cyclones = new Array();
				var t, t_d, y_m_d, h_m_s, i;
				
				for (i=0 ; i < google_time_cyclones.length ; i++) {

					cyclones.push(google_time_cyclones[i]);
					t = cyclones[i].t;

					if (t == null) {
						cyclones[i].time = null;
						cyclones[i].day = null;
						continue;
					}

					t_d = t.split(" ");
					y_m_d = t_d[0].split("-");
					if (t_d.length == 1) h_m_s = [ "00", "00", "00" ];
					else h_m_s = t_d[1].split(":");

					cyclones[i].time = h_m_s[0] + h_m_s[1];
					cyclones[i].day = time_spec.months[Number(y_m_d[1])-1] + " " + y_m_d[2];
				}

				return cyclones;
			}

			function day_and_time_to_hours(day_and_time, path) {

				var days = new Array();
				var hr, min, h1, h2, n, i;

				var hr = Number(path[0].time.substring(0, 2));
				var min = Number(path[0].time.substring(2, 4));
				h1 = hr + min / 60;

				// Get days
				for (d=null, i=0 ; i < path.length ; i++) {
					if (path[i].day !== d) {
						d = path[i].day;
						days.push(d);
					}
				}
	
				// Count days
				for (n=0 ; days[n] !== day_and_time.day ; n++) ;

				hr = Number(day_and_time.time.substring(0, 2));
				min = Number(day_and_time.time.substring(2, 4));
				h2 = hr + min / 60 - h1 + n * 24;

				return h2;
			}

			function hours_to_day_and_time(hours, timeseries, weekday_offset=null) {

				var all_days = new Array();
				var offset = Number(timeseries[0].data.time.substring(0, 2)) + Number(timeseries[0].data.time.substring(2, 4)) / 60;
				var day, time, hr, min, num_days, weekday, i;

				hours += offset;
				num_days = Math.floor(hours / 24);

				// Get day
				for (day=null, i=0 ; i < timeseries.length ; i++) {
					if (timeseries[i].data.day !== day) {
						day = timeseries[i].data.day;
						all_days.push(day);
					}
				}
				day = all_days[num_days];

				if (weekday_offset != null && all_days[0] === weekday_offset.day) {
					for (i=0 ; time_spec.weekdays[i] !== weekday_offset.weekday ; i++) ;
					weekday =  time_spec.weekdays[(i + num_days) % time_spec.weekdays.length];
				} else weekday = "";

				hr = hours - num_days * 24;
				min = Math.round((hr - Math.floor(hr)) * 60);
				hr = Math.floor(hr);
				time = (hr < 10 ? "0" : "") + hr + (min < 10 ? "0" : "") + min;

				return { day: day, time: time, weekday: weekday };
			}

			// Presume
			// (1) Path is sorted by time
			// (2) At least one time point per day
			// (3) Duration is less than 2 months
			function get_timeseries_from_path(path) {

				var timeseries = new Array();

				for (var i=0 ; i < path.length ; i++) {
					timeseries.push({
						hours: day_and_time_to_hours(path[i], path),
						data: path[i],
					});
				}

				return timeseries;
			}

			function get_valid_path(path) {

				var filtered_path = new Array();
				for (var i=0 ; i < path.length ; i++) {
					var p = path[i];
					if (p.lat != null && p.lng != null) filtered_path.push({ lat: p.lat, lng: p.lng });
				}

				return filtered_path;
			}

			function create_overlay(div, p_latLng, layer=1) {

				class overlayElement extends google.maps.OverlayView {
					constructor(div, p_latLng, layer, on_first_draw) {
						super();
						this.div = div;
						this.location = p_latLng;
						this.layer = layer;
					}
					onAdd() {
						var panes = this.getPanes();
						var thisPane = panes.floatPane;
						if (this.layer == 2) thisPane = panes.markerLayer;
						else if (this.layer == 3) thisPane = panes.overlayMouseTarget;
						else thisPane = panes.overlayLayer;
						thisPane.appendChild(this.div);
					}
					onRemove() {
						if (this.div.parentElement) this.div.parentElement.removeChild(this.div);
					}
					draw() {
						this.setDivPosition(this.location);
					}
					moveTo(p_latLng) {
						this.setDivPosition(p_latLng);
						this.location = p_latLng;
					}
					setDivPosition(p_latLng) {
						const p = this.getProjection().fromLatLngToDivPixel(p_latLng);
						this.div.style.left = p.x + "px";
						this.div.style.top = p.y + "px";
					}
					isReadyToMove() {
						return (this.getProjection() != undefined);
					}
				}

				return new overlayElement(div, p_latLng, layer);
			}

			function create_hurricane_center(p, color, annotation="") {

				var div = document.createElement("div");
				var label = document.createElement("div");
				var outer_pin = document.createElement("div");
				var inner_pin = document.createElement("div");
				var text = document.createTextNode(annotation);
				var pin;

				div.classList.add("hurricane-center");
				label.classList.add("label");
				outer_pin.classList.add("pin");
				inner_pin.classList.add("color");

				label.appendChild(text);
				div.appendChild(label);

				outer_pin.appendChild(inner_pin);
				div.appendChild(outer_pin);

				inner_pin.style.backgroundColor = color;
				pin = create_overlay(div, p, 2);

				return { pin: pin, text: text };
			}

			function interpolate_value(v1, v2, t) {
				if (v2 == null) return v1;
				else if (v1 == null) return v2;
				else return t * (v2 - v1) + v1;
			}

			function get_data_on_path(hours, timeseries) {

				var data, data1, data2, t, i;

				for (i=0 ; i < timeseries.length && hours > timeseries[i].hours ; i++) ;

				if (i == 0) data = timeseries[0].data;
				else if (i == timeseries.length) data = timeseries[timeseries.length-1].data;
				else {

					// Interpolate
					t = (hours - timeseries[i-1].hours) / (timeseries[i].hours - timeseries[i-1].hours);
					data1 = timeseries[i-1].data;
					data2 = timeseries[i].data;
					data = {
						lat:  interpolate_value(data1.lat, data2.lat, t), // Not spherical but difference is small
						lng:  interpolate_value(data1.lng, data2.lng, t), // so planar approximation is OK    
						heading: google.maps.geometry.spherical.computeHeading(
							new google.maps.LatLng(data1),
							new google.maps.LatLng(data2)
						),
						wind_max:  interpolate_value(data1.wind_max, data2.wind_max, t),
						r_wind_max:  interpolate_value(data1.r_wind_max, data2.r_wind_max, t),
						r_ne_wind_34:  interpolate_value(data1.r_ne_wind_34, data2.r_ne_wind_34, t),
						r_se_wind_34:  interpolate_value(data1.r_se_wind_34, data2.r_se_wind_34, t),
						r_sw_wind_34:  interpolate_value(data1.r_sw_wind_34, data2.r_sw_wind_34, t),
						r_nw_wind_34:  interpolate_value(data1.r_nw_wind_34, data2.r_nw_wind_34, t),
						r_ne_wind_50:  interpolate_value(data1.r_ne_wind_50, data2.r_ne_wind_50, t),
						r_se_wind_50:  interpolate_value(data1.r_se_wind_50, data2.r_se_wind_50, t),
						r_sw_wind_50:  interpolate_value(data1.r_sw_wind_50, data2.r_sw_wind_50, t),
						r_nw_wind_50:  interpolate_value(data1.r_nw_wind_50, data2.r_nw_wind_50, t),
						r_ne_wind_64:  interpolate_value(data1.r_ne_wind_64, data2.r_ne_wind_64, t),
						r_se_wind_64:  interpolate_value(data1.r_se_wind_64, data2.r_se_wind_64, t),
						r_sw_wind_64:  interpolate_value(data1.r_sw_wind_64, data2.r_sw_wind_64, t),
						r_nw_wind_64:  interpolate_value(data1.r_nw_wind_64, data2.r_nw_wind_64, t),
					};
				}

				return data;
			}

			// Chaikin's corner cutting algorithm applied to a loop of geographical coordinates
			function get_refined_loop(v) {

				var p = v;
				var p1, p2, p3, q, d, h, i, j;

				for (i=0 ; i < hurricane_spec.loop_refinement_steps ; i++) {
					q = new Array();
					for (j=0 ; j < p.length ; j++) {

						p1 = p[(j - 1 + p.length) % p.length];
						p2 = p[j]
						p3 = p[(j + 1) % p.length];

						d = google.maps.geometry.spherical.computeDistanceBetween(p2, p1);
						h = google.maps.geometry.spherical.computeHeading(p2, p1);
						q.push(google.maps.geometry.spherical.computeOffset(p2, d/4, h));

						d = google.maps.geometry.spherical.computeDistanceBetween(p2, p3);
						h = google.maps.geometry.spherical.computeHeading(p2, p3);
						q.push(google.maps.geometry.spherical.computeOffset(p2, d/4, h));
					}
					p = q;
				}

				return p;
			}

			function draw_wind_areas(hurricane, data) {

				var p = new google.maps.LatLng(data);
				var r = new Array();
				var colors = new Array();
				var alphas = new Array();
				var paths, r_ne, r_se, r_sw, r_nw, hole, v, i, j;

				for (i=0 ; i < hurricane_spec.num_wind_buckets ; i++) {

					if (i == 0) {
						r_ne = r_se = r_sw = r_nw = data.r_wind_max;
					} else if (i == 1) {
						r_ne = data.r_ne_wind_64;
						r_se = data.r_se_wind_64;
						r_sw = data.r_sw_wind_64;
						r_nw = data.r_nw_wind_64;
					} else if (i == 2) {
						r_ne = data.r_ne_wind_50;
						r_se = data.r_se_wind_50;
						r_sw = data.r_sw_wind_50;
						r_nw = data.r_nw_wind_50;
					} else {
						r_ne = data.r_ne_wind_34;
						r_se = data.r_se_wind_34;
						r_sw = data.r_sw_wind_34;
						r_nw = data.r_nw_wind_34;
					}

					// Create wind speed polygons for each time point
					if (r_ne == null || r_se == null || r_sw == null || r_nw == null) r[i] = null;
					else {
						v = new Array();
						v.push(google.maps.geometry.spherical.computeOffset(p, r_ne * 1000, 45));
						v.push(google.maps.geometry.spherical.computeOffset(p, r_se * 1000, 135));
						v.push(google.maps.geometry.spherical.computeOffset(p, r_sw * 1000, -135));
						v.push(google.maps.geometry.spherical.computeOffset(p, r_nw * 1000, -45));
						r[i] = get_refined_loop(v);
					}
				}

				colors.push(hurricane.color.wind_max);
				colors.push(hurricane.color.wind_64);
				colors.push(hurricane.color.wind_50);
				colors.push(hurricane.color.wind_34);

				alphas.push(hurricane_spec.opacity.wind_max);
				alphas.push(hurricane_spec.opacity.wind_64);
				alphas.push(hurricane_spec.opacity.wind_50);
				alphas.push(hurricane_spec.opacity.wind_34);


				for (i=0 ; i < hurricane_spec.num_wind_buckets ; i++) {

					if (r[i] == null) polygon = null;
					else {

						// Edge
						paths = new Array();
						paths.push(r[i]);

						// Hole
						for (j=i-1 ; j >= 0 && r[j] == null ; j--) ;
						if (j >= 0) {
							hole = new Array();
							for (k=r[j].length-1 ; k >= 0 ; k--) hole.push(r[j][k]);
							paths.push(hole);
						}

						polygon = new google.maps.Polygon({ paths: paths });
						polygon.setOptions(hurricane_spec.style);
						polygon.setOptions({
							fillColor: colors[i],
							fillOpacity: alphas[i],
							zIndex: hurricane.z_index + hurricane_spec.num_wind_buckets * 2 - 1 - i,
						});
						polygon.setMap(hurricane.map);
					}

					if (hurricane.polygons.wind_area[i] != null) hurricane.polygons.wind_area[i].setMap(null);
					hurricane.polygons.wind_area[i] = polygon;
				}
			}

			// Get points in loop with headings closest to path normals
			function get_tunnel_vertices(p, loop, heading_left, heading_right) {

				var v_left, v_right, d_left, d_right, heading_i, h, d, d_min, i, j;

				for (i=0 ; i < loop.length ; i++) {

					heading_i = google.maps.geometry.spherical.computeHeading(p, loop[i]);

					for (j=0 ; j < 2 ; j++) {

						if (j == 0) { h=heading_left ; d_min=d_left; }
						else { h=heading_right ; d_min=d_right; }

						d = h - heading_i;
						while (d < -180) d += 360;
						while (d > 180) d -= 360;
						d = Math.abs(d);

						if (i == 0 || d < d_min) {
							if (j == 0) {
								v_left = loop[i];
								d_left = d;
							} else {
								v_right = loop[i];
								d_right = d;
							}
						}
					}
				}

				return({ left: v_left, right: v_right });
			}


			function draw_tunnel(hurricane) {

				var hours = hurricane.wind_tunnel.start;
				var colors = new Array();
				var alphas = new Array();
				var vertices = new Array();
				var paths, hours, data, polygon, p, heading_left, heading_right, r_ne, r_se, r_sw, r_nw, r, v, w,  i, j, k;

				for (i=0 ; i < hurricane_spec.num_wind_buckets ; i++) {
					vertices.push({
						left: new Array(),
						right: new Array(),
					});
				}

				for ( ; hours <= hurricane.wind_tunnel.end ; hours+=hurricane_spec.wind_tunnel_step) {

					data = get_data_on_path(hours, hurricane.timeseries);

					p = new google.maps.LatLng(data);

					heading_left = data.heading - 90;
					if (heading_left > 180) heading_left - 360;

					heading_right = (data.heading + 90) % 360;
					if (heading_right > 180) heading_right - 360;

					for (i=0 ; i < hurricane_spec.num_wind_buckets ; i++) {

						if (i == 0) {
							r_ne = r_se = r_sw = r_nw = data.r_wind_max;
						} else if (i == 1) {
							r_ne = data.r_ne_wind_64;
							r_se = data.r_se_wind_64;
							r_sw = data.r_sw_wind_64;
							r_nw = data.r_nw_wind_64;
						} else if (i == 2) {
							r_ne = data.r_ne_wind_50;
							r_se = data.r_se_wind_50;
							r_sw = data.r_sw_wind_50;
							r_nw = data.r_nw_wind_50;
						} else {
							r_ne = data.r_ne_wind_34;
							r_se = data.r_se_wind_34;
							r_sw = data.r_sw_wind_34;
							r_nw = data.r_nw_wind_34;
						}

						if (r_ne != null && r_se != null && r_sw != null && r_nw != null) {

							// Ovoid
							v = new Array();
							v.push(google.maps.geometry.spherical.computeOffset(p, r_ne * 1000, 45));
							v.push(google.maps.geometry.spherical.computeOffset(p, r_se * 1000, 135));
							v.push(google.maps.geometry.spherical.computeOffset(p, r_sw * 1000, -135));
							v.push(google.maps.geometry.spherical.computeOffset(p, r_nw * 1000, -45));
							r = get_refined_loop(v);

							// Tunnel vertices
							w = get_tunnel_vertices(p, r, heading_left, heading_right);
							vertices[i].left.push(w.left);
							vertices[i].right.push(w.right);
						}
					}
				}

				v = new Array();
				for (i=0 ; i < hurricane_spec.num_wind_buckets ; i++) {
					v[i] = new Array();
					w = vertices[i].left;
					for (j=w.length-1 ; j >= 0 ; j--) v[i].push(w[j]);
					w = vertices[i].right;
					for (j=0 ; j < w.length ; j++) v[i].push(w[j]);
				}

				colors.push(hurricane.color.wind_max);
				colors.push(hurricane.color.wind_64);
				colors.push(hurricane.color.wind_50);
				colors.push(hurricane.color.wind_34);

				alphas.push(hurricane_spec.opacity.wind_max);
				alphas.push(hurricane_spec.opacity.wind_64);
				alphas.push(hurricane_spec.opacity.wind_50);
				alphas.push(hurricane_spec.opacity.wind_34);

				for (i=0 ; i < hurricane_spec.num_wind_buckets ; i++) {

					if (i == 0 || i+1 == hurricane_spec.num_wind_buckets) {
						hurricane.polygons.wind_tunnel[i] = null;
						continue;
					}

					// Edge
					paths = new Array();
					paths.push(v[i]);

					// Hole
					if (i > 1) {
						j =  i - 1;
						if (j >= 0) {
							w = new Array();
							for (k=v[j].length-1 ; k >= 0 ; k--) w.push(v[j][k]);
							paths.push(w);
						}
					}

					polygon = new google.maps.Polygon({ paths: paths });
					polygon.setOptions(hurricane_spec.style);
					polygon.setOptions({
						fillColor: colors[i],
						fillOpacity: alphas[i],
						zIndex: (hurricane.z_index + hurricane_spec.num_wind_buckets - 1 - i),
					});
					polygon.setMap(hurricane.map);

					hurricane.polygons.wind_tunnel[i] = polygon;
				}
			}

			function update_animation() {

				var animation = time_spec.animation;
				var t = new Date().getTime();
				var dt = t - animation.t0;
				var dh = animation.h0 + animation.speed * (dt / 1000);
				var hurricane, period, hours, data, day_and_time, max_speed, annotation, h, i;

				animation.dh = dh;

				for (i=0 ; i < map_spec.hurricanes.length ; i++) {

					hurricane = map_spec.hurricanes[i];

					period = hurricane.animation.end - hurricane.animation.start;
					hours = hurricane.animation.start + dh - Math.floor(dh / period) * period;

					data = get_data_on_path(hours, hurricane.timeseries);
					day_and_time = hours_to_day_and_time(hours, hurricane.timeseries, hurricane.weekday_offset);

					if (hurricane.center.pin.isReadyToMove()) hurricane.center.pin.moveTo(new google.maps.LatLng(data));
 
					h = Number(day_and_time.time.substring(0,2));
					if (h < 1) annotation = "12";
					else if (h < 13) annotation = h;
					else annotation = h - 12;
					if (h < 12) annotation += " AM";
					else annotation += " PM";
					annotation += "  " + day_and_time.weekday + "\n" + day_and_time.day;

					if (data.wind_max != null) {
						max_speed = Math.round(data.wind_max * hurricane_spec.mph_per_knot) + " mph";
						annotation += "\n" + max_speed;
					} else max_speed = "Maximum";

					hurricane.center.text.textContent = annotation;
					document.getElementById("max-speed-" + hurricane.name).textContent = max_speed;

					draw_wind_areas(hurricane, data);
				}
			}

			function toggle_animation(go=null) {

				var animation = time_spec.animation;

				if (go != null) {
					if (go && animation.timer != null) return;
					if (!go && animation.timer == null) return;
				}
				
				if (animation.timer == null) {
					animation.t0 = new Date().getTime();
					update_animation();
					animation.timer = setInterval(update_animation, 1.0 / time_spec.animation.frame_rate);
					return;
				}

				clearInterval(animation.timer);
				animation.h0 = animation.dh;
				animation.timer = null;
			}

			function add_hurricane(map, hurricane) {

				draw_legend(hurricane);

				hurricane.map = map;
				hurricane.data = get_nhc_time_cyclones(hurricane.data);
				hurricane.timeseries = get_timeseries_from_path(hurricane.data);

				hurricane.path = new google.maps.Polyline({
					path: get_valid_path(hurricane.data),
					geodesic: true,
					strokeColor: hurricane.color.path,
					strokeOpacity: 1.0,
					strokeWeight: hurricane_spec.path.width,
				});
			    hurricane.path.setMap(map);

				if (hurricane.animation.end == null) {
					hurricane.animation.end = hurricane.timeseries[hurricane.timeseries.length-1].hours;
				}

				hurricane.center = create_hurricane_center(
					new google.maps.LatLng(hurricane.timeseries[0].data),
					hurricane.color.path
				);
				hurricane.center.pin.setMap(map);

				hurricane.z_index = hurricane_spec.z_index + map_spec.hurricanes.length * hurricane_spec.num_wind_buckets;

				map_spec.hurricanes.push(hurricane);
			}

			function draw_legend(hurricane) {

				var colors = [
					hurricane.color.wind_34,
					hurricane.color.wind_50,
					hurricane.color.wind_64,
					hurricane.color.wind_max,
				];
				var alphas = [
					hurricane_spec.opacity.wind_34,
					hurricane_spec.opacity.wind_50,
					hurricane_spec.opacity.wind_64,
					hurricane_spec.opacity.wind_max,
				];
				var ticks = [
					Math.round(34 * hurricane_spec.mph_per_knot) + "+ mph",
					Math.round(50 * hurricane_spec.mph_per_knot) + "+ mph",
					Math.round(64 * hurricane_spec.mph_per_knot) + "+ mph",
					"Maximum"
				];
				var legend_div = document.getElementById("legend-" + hurricane.name);
				var color_div = document.createElement("div");
				var ticks_div = document.createElement("div");
				var div, i;

				color_div.classList.add("colors");
				ticks_div.classList.add("ticks");

				legend_div.appendChild(color_div);
				legend_div.appendChild(ticks_div);

				for (i=0 ; i < colors.length ; i++) {

					div = document.createElement("div");
					color_div.appendChild(div);
					div.style.background = colors[i];

					div = document.createElement("div");
					ticks_div.appendChild(div);
					div.textContent = ticks[i];

					if (i+1 == colors.length) div.id = "max-speed-" + hurricane.name;
				}
			}

			function switch_display(type=null) {

				var tab_areas = document.getElementById("areas");
				var tab_tunnels = document.getElementById("tunnels");
				var hurricane, map, i, j;

				if (type == null) {
					if (tab_areas.classList.contains("selected")) type = "tunnels";
					else if (tab_tunnels.classList.contains("selected")) type = "areas";
					else type = "areas";
				}

				if (type === "areas") tab_areas.classList.add("selected");
				else tab_areas.classList.remove("selected");

				if (type === "tunnels") tab_tunnels.classList.add("selected");
				else tab_tunnels.classList.remove("selected");

				if (type === "areas") {

					for (i=0 ; i < map_spec.hurricanes.length ; i++) {
						hurricane = map_spec.hurricanes[i];
						map = hurricane.map;
						hurricane.path.setMap(map);
						hurricane.center.pin.setMap(map);
						for (j=0 ; j < hurricane_spec.num_wind_buckets ; j++) {
							if (hurricane.polygons.wind_area[j] != null) hurricane.polygons.wind_area[j].setMap(map);
							if (hurricane.polygons.wind_tunnel[j] != null) hurricane.polygons.wind_tunnel[j].setMap(null);
						}
					}

					toggle_animation(true);

				} else if (type === "tunnels") {

					for (i=0 ; i < map_spec.hurricanes.length ; i++) {
						hurricane = map_spec.hurricanes[i];
						map = hurricane.map;
						hurricane.path.setMap(null);
						hurricane.center.pin.setMap(null);
						for (j=0 ; j < hurricane_spec.num_wind_buckets ; j++) {
							if (hurricane.polygons.wind_area[j] != null) hurricane.polygons.wind_area[j].setMap(null);
							if (hurricane.polygons.wind_tunnel[j] != null) hurricane.polygons.wind_tunnel[j].setMap(map);
						}
					}

					toggle_animation(false);

				}
			}

			async function initialize() {

				const { Map } = await google.maps.importLibrary("maps");
				const { geometry } = await google.maps.importLibrary("geometry");

				var div = document.getElementById("map");
				var map = new google.maps.Map(div, {
					center: map_spec.center,
					zoom: map_spec.zoom,
					mapTypeId: 'hybrid',
					disableDefaultUI: true,
					zoomControl: true,
				    zoomControlOptions: { position: google.maps.ControlPosition.RIGHT_TOP },
				});

				map.fitBounds(
					new google.maps.LatLngBounds(
						new google.maps.LatLng(map_spec.bounds.southwest),
						new google.maps.LatLng(map_spec.bounds.northeast)
					),
					{ top: 0, right: 0, bottom: 0, left: 0 }
				);

				add_hurricane(map, beryl_spec);
				add_hurricane(map, melissa_spec);

				draw_tunnel(beryl_spec);
				draw_tunnel(melissa_spec);

				switch_display("areas");
			}

			// Bootstrap loader (Dynamic Library Import API)
			(g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await (a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
				key: "AIzaSyCqHHpYbRdkCj5_gWK6V51ZRuAK__gg1-8",
    			v: "weekly",
			});
		</script>

		<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

		<style>
			body {
				margin: 0px;
				font-family: "Roboto", Arial, sans-serif;
			}
			.map {
				width: 100vw;
				height: 100vh;
   			}
			.hurricane-center {
				position: absolute;
				left: 0;
				top: 0;
				transform: translate(-50%, -100%) translateY(14px);
				padding: 2px 6px 6px 6px;
				border-radius: 8px 8px 24px 24px;
			}
			.hurricane-center .label {
				position: relative;
				top: -4px;
				text-align: center;
				font-size: 14px;
				line-height: 16px;
				color: white;
			    filter: drop-shadow(0px 2px 2px rgba(0, 0, 0, 0.5));
				white-space: pre-line;
			}
			.hurricane-center .pin {
				margin: 0 auto;
				width: 16px;
				height: 16px;
				border-radius: 8px;
				background-color: white;
			    filter: drop-shadow(0px 2px 2px rgba(0, 0, 0, 0.5));
			}
			.hurricane-center .color {
				transform: translate(2px, 2px);
				width: 12px;
				height: 12px;
				border-radius: 6px;
			}
			.card {
				position: absolute;
				bottom: 12px;
				left: 16px;
				padding: 12px 14px;
				border-radius: 8px;
				background-color: rgba(255, 255, 255, 0.85);
			    filter: drop-shadow(0px 2px 2px rgba(0, 0, 0, 0.3));
				line-height: 18px;
			}
			.two-legends {
				display: grid;
				grid-template-columns: max-content max-content;
				column-gap: 16px;
				row-gap: 0px;
			}
			.card, .attribution, a {
				font-size: 14px;
				line-height: 16px;
				color: #202124;
			}
			.colors {
				margin: 6px 0 0 0;
				border: 1px solid #dadce0;
				opacity: 0.7;
				height: 24px;
			}
			.colors div {
				display: inline-block;
				width: 72px;
				height: 20px;
			}
			.colors div:first-child {
				border-top-left-radius: 4px;
				border-bottom-left-radius: 4px;
			}
			.colors div:last-child {
				border-top-right-radius: 4px;
				border-bottom-right-radius: 4px;
			}
			.ticks div {
				display: inline-block;
				width: 72px;
				text-align: center;
				line-height: 14px;
				white-space: no-wrap;
				margin-bottom: 12px;
			}
			.tabs {
				position: absolute;
				top: 12px;
				left: 16px;
				display: grid;
				grid-template-columns: max-content max-content;
				column-gap: 12px;
			}
			.tabs div {
				font-weight: 500;
				line-height: 34px;
				color: #80868b;
				padding: 0 15px;
				border-radius: 8px;
				border: 1px solid #dadce0;
				background-color: rgba(255, 255, 255, 0.8);
			    user-select: none;
				cursor: pointer;
			}
			.tabs div.selected {
				border: 1px solid #e8f0fe;
				color: #1967d2;
				background-color: #e8f0fe;
				pointer-events: none;
			}
			.tabs div.selected::before {
		    	content: url("data:image/svg+xml; utf8, <svg width='20' height='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 14.2 L2.8 10 L1.4 11.4 L7 17 L19 5 L17.6 3.6 L7 14.2Z' fill='blue' fill-opacity='0.8' stroke='none'/></svg>");
				position: relative;
				top: 5px;
				left: -6px;
				margin-right: 2px;
			}
			.tabs div:hover {
				color: #3c4043;
				background-color: #ffffff;
			}
			a[href^="http://maps.google.com/maps"] {
				display:none !important;
			}
			a[href^="https://maps.google.com/maps"] {
				display:none !important;
			}
			.gmnoprint a, .gmnoprint span, .gm-style-cc {
			    display:none;
			}
			.gmnoprint div {
			    background:none !important;
			}
		</style>
	</head>

	<body onload="initialize()">
		<div class="map" id="map"></div>
		<div class="tabs">
			<div id="areas" onclick="switch_display()">Wind speeds over time</div>
			<div id="tunnels" onclick="switch_display()">Wind tunnels</div>
		</div>
		<div class="card">
			<div class="two-legends">
				<div class="title">Hurricane Melissa wind speeds (Oct 2025)</div>
				<div class="title">Hurricane Beryl wind speeds (July 2024)</div>
				<div class="legend" id="legend-Melissa"></div>
				<div class="legend" id="legend-Beryl"></div>
			</div>
			<div class="attribution">
				Visualizations based on data from
				<a href="https://deepmind.google.com/science/weatherlab" target="_blank" rel="noopener noreferrer">
					Google Weather Lab Preview: Cyclones</a>
				(license
				<a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer">CC BY 4.0</a>)
			</div>
		</div>
	</body>

</html>