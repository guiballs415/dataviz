<!doctype html>
<html lang="en">

	<head>
	    <meta charset="utf-8">
		<title>Dataviz examples for a document form factor</title>

		<script src="data/wind-areas-melissa.js"></script>
		<script src="data/wind-jamaica-melissa.js"></script>
		<script src="doc-charts-maps.js"></script>
		<script src="doc-charts-tables.js"></script>
		<script src="doc-charts.js"></script>

		<link rel="stylesheet" href="doc-charts.css">

		<script>
			var chat_spec = [

				// Initial hurricane question
				{ prompt: "Where are hurricane force winds likely in Jamaica?",
					prologue: "I can use cyclone forecasts to identify areas in Jamaica where hurricane force winds are likely from Hurricane Melissa. Cyclone forecasts include predictions of the size and shape of areas around the center of the hurricane with extreme wind speeds. Forecasts over time can be combined to predict which areas will have hurricane force winds at some point in Melissa's life cycle. Here's how I'll do it:",
					plan: [
						{ step: "Get latest forecasts for Hurricane Melissa.",
						 	data_source: "Forecasts are generated by Google’s Experimental Cyclones Model.",
								learn_more: "https://deepmind.google.com/science/go/oXliuwUb776gN5Cp" },
						{ step: "For each time point in the forecasts, calculate the boundaries of each of the oval wind speed areas." },
						{ step: "For each time point, find the points where the boundaries of the wind speed areas intersect the line passing through the center of the hurricane and perpendicular to the predicted path." },
						{ step: "Create polygons for each wind speed area by connecting the boundary intersections and show them on the map." },
					],
					results: [
						{ text: "Areas where hurricane force winds are likely are highlighted on the map:" },
						{ map: "Hurricane force winds", spec: melissa_spec },
					],
				},

				// Drill down into specific locations
				{ prompt: "Which parishes will be affected?",
					prologue: "I'll analyze each parish by comparing polygons for hurricane force winds to each parish's boundaries:",
					plan: [
						{ step: "Get boundaries for Jamaica parishes.",
							data_source: "Administrative boundaries are generated by Google Maps Platform's Places API.",
								learn_more: "https://developers.google.com/maps/documentation/places/web-service/overview" },
						{ step: "Find parishes with boundaries than intersect with the hurricane force wind areas and list them." },
					],
					results: [
						{ text: "Hurricane force winds are likely in some places in St\u00A0Elizabeth, Westmoreland, Hanover, St\u00A0James, Trelawny, Manchester and St\u00A0Ann but high winds are expected in other parishes too. Here's a breakdown of the maximum wind speeds per parish:" },
						{ table: "Expected winds speeds", spec: parishes_table_spec },
					],
				},

				// Drill down into temporal details
				{ prompt: "When will hurricane force winds happen in the parishes?",
					prologue: "I can create a time series of the maximum wind speed expected for each parish to estimate when hurricane force winds will arrive and how long they'll last. I'll use the wind speed areas to model the wind speed distribution between the center of the cyclone and the center of the each parish. Here's how I'll do it:",
					plan: [
						{ step: "Calculate the centroid of each parish from its boundary coordinates." },
						{ step: "For each parish, for each time point in the forecasts, find the locations where the line from the center of the cyclone to the center of the parish intersects the boundaries of the oval wind speed areas. Use the wind speeds corresponding to the boundary intersections to create a series of data points for wind speed as a function of distance from the center of the cyclone. Fit a smooth curve to the data points and use it to estimate wind speed at the center of the parish. Create a time series of the estimated wind speeds." },
						{ step: "For each parish, use its time series to estimate the period when hurricane force winds are likely." },
						{ step: "Create a time series chart showing when the wind speeds are predicted to rise to hurricane force (≥\u00A074\u00A0mph)." },
					],
					results: [
						{ text: "The chart below shows that winds are predicted to rise to hurricane force around 9:15\u00A0am on Oct\u00A028 in Westmoreland and St\u00A0Elizabeth and continue for more than 4\u00A0hours. Hurricane force winds are predicted to begin around 11:30\u00A0am in St\u00A0James and Trelawny and continue for about 5\u00A0hours." },
						{ chart: "Expected winds speeds", spec: parishes_chart_spec },
						{ table: "Arrival times and duration of hurricane force winds", spec: timeseries_table_spec },
					],
				},
			];

			function add_div(div) {

				document.getElementById("chat").appendChild(div);
			}

			function add_prompt(text) {

				var container = document.createElement("div");
				var div = document.createElement("div");

				container.classList.add("prompt");
				container.appendChild(div);

				div.classList.add("bubble");
				div.textContent = text;

				add_div(container);
			}

			function add_text(text) {

				var div = document.createElement("div");

				div.classList.add("text");
				div.textContent = text;

				add_div(div);
			}

			function add_plan(plan) {

				var container = document.createElement("div");
				var step, div, zippy, text, span, link, i;

				container.classList.add("plan");

				for (i=0 ; i < plan.length ; i++) {

					step = plan[i];

					div = document.createElement("div");
					div.classList.add("status");
					container.appendChild(div);

					// Mark everything completed for purposes of mock
					div.classList.add("completed");

					div = document.createElement("div");
					div.classList.add("step");
					container.appendChild(div);

					if (step.data_source == undefined) {
						div.textContent = step.step;
						continue;
					}

					div.classList.add("get-data");
					div.addEventListener("click", click_get_data_step);

					zippy = document.createElement("div");
					zippy.classList.add("zippy");
					div.appendChild(zippy);

					text = document.createTextNode(step.step);
					div.appendChild(text);

					span = document.createElement("span");
					span.classList.add("data-source");
					span.textContent = " " + step.data_source + " ";
					div.appendChild(span);

					if (step.learn_more == undefined) continue;

					link = document.createElement("a");
					link.classList.add("learn-more");
					link.href = step.learn_more;
					link.textContent = "Learn more";
					link.target = "_blank";
					div.appendChild(link);
				}

				add_div(container);
			}

			function add_map(spec) {

				var div = document.createElement("div");
				var legend = document.createElement("div");

				div.classList.add("map");
				legend.classList.add("map-legend");

				create_map(spec, div, legend);

				add_div(legend);
				add_div(div);
			}

			function add_table(spec) {

				var div = document.createElement("div");

				div.classList.add("table");

				create_table(spec, div);

				add_div(div);
			}

			function add_chart(spec) {

				var div = document.createElement("div");

				div.classList.add("chart");

				create_chart(spec, div);

				add_div(div);
			}

			function add_results(results) {

				var item, i;

				for (i=0 ; i < results.length ; i++) {

					item = results[i];

					if (item.text != undefined) add_text(item.text);
					else if (item.map != undefined) add_map(item.spec);
					else if (item.table != undefined) add_table(item.spec);
					else if (item.chart != undefined) add_chart(item.spec);
				}
			}

			function click_get_data_step(event) {

				if (event.target.classList.contains("learn-more")) return;

				var step = event.currentTarget;
				if (step.classList.contains("expanded")) step.classList.remove("expanded");
				else step.classList.add("expanded");
			}

			function draw_chat() {

				var response, i;

				for (i=0 ; i < chat_spec.length ; i++) {

					response = chat_spec[i];

					add_prompt(response.prompt);
					add_text(response.prologue);
					add_plan(response.plan);
					add_results(response.results);
				}
			}

			function show_maximized_content(content) {

				var popup = document.getElementById("popup");

				content.id = "popup-content";
				popup.appendChild(content);

				document.getElementsByTagName("body")[0].classList.add("popup");
			}

			function hide_maximized_content() {

				var popup = document.getElementById("popup");
				var content = document.getElementById("popup-content");

				popup.removeChild(content);

				document.getElementsByTagName("body")[0].classList.remove("popup");
			}

			async function initialize() {

				const { Map } = await google.maps.importLibrary("maps");

				draw_chat();
			}
		</script>
	</head>

	<body onload="initialize()">
		<div class="chat" id="chat"></div>
		<div class="popup" id="popup">
			<div class="close-button" onclick="hide_maximized_content()"></div>
		</div>
		<div class="stamp">Mockup</div>
	</body>
</html>